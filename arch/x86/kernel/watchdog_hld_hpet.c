// SPDX-License-Identifier: GPL-2.0
/*
 * A hardlockup detector driven by an HPET timer.
 *
 * Copyright (C) Intel Corporation 2019
 *
 * A hardlockup detector driven by an HPET timer. It implements the same
 * interfaces as the PERF-based hardlockup detector.
 *
 * A single HPET timer is used to monitor all the CPUs from the allowed_mask
 * from kernel/watchdog.c. Thus, the timer is programmed to expire every
 * watchdog_thresh/cpumask_weight(watchdog_allowed_cpumask). The timer targets
 * CPUs in round robin manner. Thus, every cpu in watchdog_allowed_mask is
 * monitored every watchdog_thresh seconds.
 */

#define pr_fmt(fmt) "NMI hpet watchdog: " fmt

#include <linux/nmi.h>
#include <linux/hpet.h>
#include <asm/msidef.h>
#include <asm/hpet.h>

static struct hpet_hld_data *hld_data;
static bool hardlockup_use_hpet;
static u64 tsc_next_error;

/**
 * kick_timer() - Reprogram timer to expire in the future
 * @hdata:	A data structure with the timer instance to update
 * @force:	Force reprogramming
 *
 * Reprogram the timer to expire within watchdog_thresh seconds in the future.
 * If the timer supports periodic mode, it is not kicked unless @force is
 * true.
 *
 * Also, compute the expected value of the time-stamp counter at the time of
 * expiration as well as a deviation from the expected value. The maximum
 * deviation is of ~1.5%. This deviation can be easily computed by shifting
 * by 6 positions the delta between the current and expected time-stamp values.
 */
static void kick_timer(struct hpet_hld_data *hdata, bool force)
{
	u64 tsc_curr, tsc_delta, new_compare, count, period = 0;
	bool kick_needed = force || !(hdata->has_periodic);

	tsc_curr = rdtsc();

	tsc_delta = (unsigned long)watchdog_thresh * hdata->tsc_ticks_per_cpu;
	hdata->tsc_next = tsc_curr + tsc_delta;
	tsc_next_error = tsc_delta >> 6;

	/*
	 * Update the comparator in increments of watch_thresh seconds relative
	 * to the current count. Since watch_thresh is given in seconds, we
	 * are able to update the comparator before the counter reaches such new
	 * value.
	 *
	 * Each CPU must be monitored every watch_thresh seconds. Since the
	 * timer targets one CPU at a time, it must expire every
	 *
	 *        ticks_per_cpu = watch_thresh * ticks_per_second /enabled_cpus
	 *
	 * as computed in update_ticks_per_cpu().
	 *
	 * Let it wrap around if needed.
	 */

	if (!kick_needed)
		return;

	if (hdata->has_periodic)
		period = watchdog_thresh * hdata->ticks_per_cpu;

	count = hpet_readl(HPET_COUNTER);
	new_compare = count + watchdog_thresh * hdata->ticks_per_cpu;
	hpet_set_comparator(hdata->num, (u32)new_compare, (u32)period);
}

static void disable_timer(struct hpet_hld_data *hdata)
{
	u32 v;

	v = hpet_readl(HPET_Tn_CFG(hdata->num));
	v &= ~HPET_TN_ENABLE;
	hpet_writel(v, HPET_Tn_CFG(hdata->num));
}

static void enable_timer(struct hpet_hld_data *hdata)
{
	u32 v;

	v = hpet_readl(HPET_Tn_CFG(hdata->num));
	v |= HPET_TN_ENABLE;
	hpet_writel(v, HPET_Tn_CFG(hdata->num));
}

/**
 * is_hpet_wdt_interrupt() - Check if an HPET timer caused the interrupt
 * @hdata:	A data structure with the timer instance to enable
 *
 * Returns:
 * True if the HPET watchdog timer caused the interrupt. False otherwise.
 */
static bool is_hpet_wdt_interrupt(struct hpet_hld_data *hdata)
{
	if (smp_processor_id() == hdata->handling_cpu) {
		u64 tsc_curr;

		tsc_curr = rdtsc();

		return (tsc_curr - hdata->tsc_next) + tsc_next_error <
		       2 * tsc_next_error;
	}

	return false;
}

/**
 * compose_msi_msg() - Populate address and data fields of an MSI message
 * @hdata:	A data strucure with the message to populate
 *
 * Initialize the fields of the MSI message to deliver an NMI interrupt. This
 * function only initialize the files that don't change during the operation of
 * of the detector. This function does not populate the Destination ID; which
 * should be populated using update_msi_destid().
 */
static void compose_msi_msg(struct hpet_hld_data *hdata)
{
	struct msi_msg *msg = &hdata->msi_msg;

	/*
	 * The HPET FSB Interrupt Route register does not have an
	 * address_hi part.
	 */
	msg->address_lo = MSI_ADDR_BASE_LO;

	if (apic->irq_dest_mode == 0)
		msg->address_lo |= MSI_ADDR_DEST_MODE_PHYSICAL;
	else
		msg->address_lo |= MSI_ADDR_DEST_MODE_LOGICAL;

	msg->address_lo |= MSI_ADDR_REDIRECTION_CPU;

	/*
	 * On edge trigger, we don't care about assert level. Also,
	 * since delivery mode is NMI, no irq vector is needed.
	 */
	msg->data = MSI_DATA_TRIGGER_EDGE | MSI_DATA_LEVEL_ASSERT |
		    MSI_DATA_DELIVERY_NMI;
}

/** update_msi_destid() - Update APIC destid of handling CPU
 * @hdata:	A data strucure with the MSI message to update
 *
 * Update the APIC destid of the MSI message generated by the HPET timer
 * on expiration.
 */
static int update_msi_destid(struct hpet_hld_data *hdata)
{
	u32 destid;

	hdata->msi_msg.address_lo &= ~MSI_ADDR_DEST_ID_MASK;
	destid = apic->calc_dest_apicid(hdata->handling_cpu);
	hdata->msi_msg.address_lo |= MSI_ADDR_DEST_ID(destid);

	hpet_writel(hdata->msi_msg.address_lo, HPET_Tn_ROUTE(hdata->num) + 4);

	return 0;
}

/**
 * hardlockup_detector_nmi_handler() - NMI Interrupt handler
 * @type:	Type of NMI handler; not used.
 * @regs:	Register values as seen when the NMI was asserted
 *
 * Check if it was caused by the expiration of the HPET timer. If yes, inspect
 * for lockups. Also, prepare the HPET timer to target the next monitored CPU
 * and kick it.
 *
 * Returns:
 * NMI_DONE if the HPET timer did not cause the interrupt. NMI_HANDLED
 * otherwise.
 */
static int hardlockup_detector_nmi_handler(unsigned int type,
					   struct pt_regs *regs)
{
	struct hpet_hld_data *hdata = hld_data;
	u32 cpu = smp_processor_id();

	if (!is_hpet_wdt_interrupt(hdata))
		return NMI_DONE;

	inspect_for_hardlockups(regs);

	cpu = cpumask_next(cpu, to_cpumask(hdata->cpu_monitored_mask));
	if (cpu >= nr_cpu_ids)
		cpu = cpumask_first(to_cpumask(hdata->cpu_monitored_mask));

	hdata->handling_cpu = cpu;
	update_msi_destid(hdata);
	kick_timer(hdata, !(hdata->has_periodic));

	return NMI_HANDLED;
}

/**
 * setup_irq_msi_mode() - Configure the timer to deliver an MSI interrupt
 * @data:	Data associated with the instance of the HPET timer to configure
 *
 * Configure the HPET timer to deliver interrupts via the Front-
 * Side Bus.
 *
 * Returns:
 * 0 success. An error code in configuration was unsuccessful.
 */
static int setup_irq_msi_mode(struct hpet_hld_data *hdata)
{
	u32 v;

	compose_msi_msg(hdata);
	hpet_writel(hdata->msi_msg.data, HPET_Tn_ROUTE(hdata->num));
	hpet_writel(hdata->msi_msg.address_lo, HPET_Tn_ROUTE(hdata->num) + 4);

	/*
	 * Since FSB interrupt delivery is used, configure as edge-triggered
	 * interrupt.
	 */
	v = hpet_readl(HPET_Tn_CFG(hdata->num));
	v &= ~HPET_TN_LEVEL;
	v |= HPET_TN_FSB;

	hpet_writel(v, HPET_Tn_CFG(hdata->num));

	return 0;
}

/**
 * setup_hpet_irq() - Configure the interrupt delivery of an HPET timer
 * @data:	Data associated with the instance of the HPET timer to configure
 *
 * Configure the interrupt parameters of an HPET timer. If supported, configure
 * interrupts to be delivered via the Front-Side Bus. Also, install an interrupt
 * handler.
 *
 * Returns:
 * 0 success. An error code in configuration was unsuccessful.
 */
static int setup_hpet_irq(struct hpet_hld_data *hdata)
{
	int ret;

	ret = setup_irq_msi_mode(hdata);
	if (ret)
		return ret;

	ret = register_nmi_handler(NMI_WATCHDOG,
				   hardlockup_detector_nmi_handler, 0,
				   "hpet_hld");

	return ret;
}

/**
 * update_ticks_per_cpu() - Update the number of HPET ticks per CPU
 * @hdata:     struct with the timer's the ticks-per-second and CPU mask
 *
 * From the overall ticks-per-second of the timer, compute the number of ticks
 * after which the timer should expire to monitor each CPU every watch_thresh
 * seconds. The ticks-per-cpu quantity is computed using the number of CPUs that
 * the watchdog currently monitors.
 */
static void update_ticks_per_cpu(struct hpet_hld_data *hdata)
{
	u64 temp = hdata->ticks_per_second;

	/* Only update if there are monitored CPUs. */
	if (!hdata->enabled_cpus)
		return;

	do_div(temp, hdata->enabled_cpus);
	hdata->ticks_per_cpu = temp;

	temp = (unsigned long)tsc_khz * 1000L;
	do_div(temp, hdata->enabled_cpus);
	hdata->tsc_ticks_per_cpu = temp;
}

/**
 * hardlockup_detector_hpet_enable() - Enable the hardlockup detector
 * @cpu:	CPU Index in which the watchdog will be enabled.
 *
 * Enable the hardlockup detector in @cpu. This means adding it to the
 * cpumask of monitored CPUs. If @cpu is the first one for which the
 * hardlockup detector is enabled, enable and kick the timer.
 */
void hardlockup_detector_hpet_enable(unsigned int cpu)
{
	cpumask_set_cpu(cpu, to_cpumask(hld_data->cpu_monitored_mask));

	hld_data->enabled_cpus++;
	update_ticks_per_cpu(hld_data);

	if (hld_data->enabled_cpus == 1) {
		hld_data->handling_cpu = cpu;
		update_msi_destid(hld_data);
		/* Force timer kick when detector is just enabled */
		kick_timer(hld_data, true);
		enable_timer(hld_data);
	}

	/*
	 * When in periodic mode, we only kick the timer here. Hence,
	 * as there are now more CPUs to monitor, we need to adjust the
	 * periodic expiration.
	 */
	kick_timer(hld_data, hld_data->has_periodic);
}

/**
 * hardlockup_detector_hpet_disable() - Disable the hardlockup detector
 * @cpu:	CPU index in which the watchdog will be disabled
 *
 * @cpu is removed from the cpumask of monitored CPUs. If @cpu is also the CPU
 * handling the timer interrupt, update it to be the next available, monitored,
 * CPU.
 */
void hardlockup_detector_hpet_disable(unsigned int cpu)
{
	cpumask_clear_cpu(cpu, to_cpumask(hld_data->cpu_monitored_mask));
	hld_data->enabled_cpus--;

	update_ticks_per_cpu(hld_data);

	if (hld_data->handling_cpu != cpu)
		return;

	disable_timer(hld_data);
	if (!hld_data->enabled_cpus)
		return;

	cpu = cpumask_first(to_cpumask(hld_data->cpu_monitored_mask));
	hld_data->handling_cpu = cpu;
	update_msi_destid(hld_data);
	enable_timer(hld_data);
}

void hardlockup_detector_hpet_stop(void)
{
	disable_timer(hld_data);
}

/**
 * hardlockup_detector_hpet_init() - Initialize the hardlockup detector
 *
 * Only initialize and configure the detector if an HPET is available on the
 * system.
 *
 * Returns:
 * 0 success. An error code if initialization was unsuccessful.
 */
int __init hardlockup_detector_hpet_init(void)
{
	int ret;
	u32 v;

	if (!hardlockup_use_hpet)
		return -ENODEV;

	if (!is_hpet_enabled())
		return -ENODEV;

	if (check_tsc_unstable())
		return -ENODEV;

	hld_data = hpet_hardlockup_detector_assign_timer();
	if (!hld_data)
		return -ENODEV;

	disable_timer(hld_data);

	ret = setup_hpet_irq(hld_data);
	if (ret) {
		kfree(hld_data);
		hld_data = NULL;
	}

	v = hpet_readl(HPET_Tn_CFG(hld_data->num));
	v |= HPET_TN_32BIT;

	if (hld_data->has_periodic)
		v |= HPET_TN_PERIODIC;
	else
		v &= ~HPET_TN_PERIODIC;

	hpet_writel(v, HPET_Tn_CFG(hld_data->num));

	return ret;
}
